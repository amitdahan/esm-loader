import{installSourceMapSupport as d,transform as u,transformDynamicImport as g}from"@esbuild-kit/core-utils";import w from"get-tsconfig";import R from"path";import{init as $}from"es-module-lexer";import _ from"fs";import{fileURLToPath as N}from"url";const c=/\.([cm]?ts|[tj]sx)$/,y=t=>{const o=R.extname(t);if(o===".mts")return"module";if(o===".cts")return"commonjs"};$.then(()=>{});const p=new Map;async function W(t){if(p.has(t))return p.get(t);if(!await _.promises.access(t).then(()=>!0,()=>!1)){p.set(t,void 0);return}const r=await _.promises.readFile(t,"utf8");try{const s=JSON.parse(r);return p.set(t,s),s}catch{throw new Error(`Error parsing: ${t}`)}}async function b(t){let o=new URL("package.json",t);for(;!o.pathname.endsWith("/node_modules/package.json");){const r=N(o),s=await W(r);if(s)return s;const e=o;if(o=new URL("../package.json",o),o.pathname===e.pathname)break}}async function h(t){var o;const r=await b(t);return(o=r==null?void 0:r.type)!=null?o:"commonjs"}var x=Object.defineProperty,T=Object.defineProperties,I=Object.getOwnPropertyDescriptors,l=Object.getOwnPropertySymbols,F=Object.prototype.hasOwnProperty,L=Object.prototype.propertyIsEnumerable,O=(t,o,r)=>o in t?x(t,o,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[o]=r,j=(t,o)=>{for(var r in o||(o={}))F.call(o,r)&&O(t,r,o[r]);if(l)for(var r of l(o))L.call(o,r)&&O(t,r,o[r]);return t},v=(t,o)=>T(t,I(o));const P=d(),k=w(),M=k==null?void 0:k.config,A=/\.\w+$/,E=[".js",".json",".ts",".tsx",".jsx"],V=[...E,...E.map(t=>`/index${t}`)],i=async function(t,o,r){var s;if(t.startsWith("node:")&&(t=t.slice(5)),t.endsWith("/"))return i(`${t}index`,o,r);if(/\.[cm]js$/.test(t)&&c.test(o.parentURL))try{return await i(`${t.slice(0,-2)}ts`,o,r)}catch(n){if(n.code!=="ERR_MODULE_NOT_FOUND")throw n}let e;try{e=await r(t,o,r)}catch(n){if(n instanceof Error){if(n.code==="ERR_UNSUPPORTED_DIR_IMPORT")return i(`${t}/index`,o,r);if(n.code==="ERR_MODULE_NOT_FOUND"&&!A.test(t))for(const a of V)try{const J=t+(t.endsWith("/")&&a.startsWith("/")?a.slice(1):a);return await i(J,o,r)}catch{}}throw n}if(e.url.endsWith(".json"))return v(j({},e),{format:"json"});if(c.test(e.url)){const n=(s=y(e.url))!=null?s:await h(e.url);return v(j({},e),{format:n})}return e},C=async function(t,o,r){process.send&&process.send({type:"dependency",path:t}),t.endsWith(".json")&&(o.importAssertions||(o.importAssertions={}),o.importAssertions.type="json");const s=await r(t,o,r);if(!s.source)return s;const e=s.source.toString();if(s.format==="json"||c.test(t)){const a=await u(e,t,{format:"esm",tsconfigRaw:M});return a.map&&P.set(t,a.map),{format:"module",source:a.code}}const n=g({code:e});return n&&(s.source=n.code,n.map&&P.set(t,n.map)),s},S=w(),q=S==null?void 0:S.config,U=d(),z=async function(t,o,r){var s;return t.endsWith(".json")?{format:"module"}:c.test(t)?{format:(s=y(t))!=null?s:await h(t)}:await r(t,o,r)},B=async function(t,o,r){const{url:s}=o;if(process.send&&process.send({type:"dependency",path:s}),s.endsWith(".json")||c.test(s)){const a=await u(t.toString(),s,{format:"esm",tsconfigRaw:q});return a.map&&U.set(s,a.map),{source:a.code}}const e=await r(t,o,r),n=g({code:e.source});return n&&(e.source=n.code,n.map&&U.set(s,n.map)),e},m=[16,12,0],f=process.version.slice(1).split(".").map(Number),D=(f[0]-m[0]||f[1]-m[1]||f[2]-m[2])<0,H=D?z:void 0,K=D?B:void 0;export{H as getFormat,C as load,i as resolve,K as transformSource};
